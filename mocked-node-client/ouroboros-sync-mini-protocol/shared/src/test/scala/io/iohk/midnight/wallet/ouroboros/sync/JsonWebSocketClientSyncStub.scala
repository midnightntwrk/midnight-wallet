package io.iohk.midnight.wallet.ouroboros.sync

import cats.Show
import cats.effect.std.{Queue, Random}
import cats.effect.{IO, Ref}
import cats.syntax.all.*
import io.circe.{Decoder, Encoder}
import io.iohk.midnight.wallet.ouroboros.network.JsonWebSocketClient
import io.iohk.midnight.wallet.ouroboros.sync.TestDomain.{Block, Transaction}
import io.iohk.midnight.wallet.ouroboros.sync.protocol.LocalBlockSync.Receive.RollForward
import io.iohk.midnight.wallet.ouroboros.sync.protocol.LocalBlockSync.{Hash, Receive, Send}

/** A dummy implementation of a websocket client for syncing. It holds a queue of blocks, simulating
  * the blocks that are in the blockchain but not synced yet. Allows for simulating new blocks
  * generated by the blockchain through an `emitBlock` method.
  */
class JsonWebSocketClientSyncStub(
    currentHeight: Ref[IO, Int],
    blocks: Queue[IO, Block],
    responses: Queue[IO, Receive[Block]],
    clientIsAwaitingReply: Ref[IO, Boolean],
)(implicit R: Random[IO])
    extends JsonWebSocketClient[IO] {

  override def send[T: Encoder](message: T): IO[Unit] =
    message match {
      case Send.RequestNext =>
        blocks.tryTake
          .flatMap[Receive[Block]] {
            case Some(block) => Receive.RollForward(block).pure[IO].widen
            case None        => clientIsAwaitingReply.set(true).as(Receive.AwaitReply)
          }
          .flatMap(responses.offer)

      case msg =>
        implicit val show: Show[T] = Show.fromToString
        new Exception(s"Unexpected message ${msg.show}").raiseError[IO, Unit]
    }

  @SuppressWarnings(Array("org.wartremover.warts.AsInstanceOf"))
  override def receive[T: Decoder](): IO[T] =
    responses.take.map(_.asInstanceOf[T])

  def emitBlock(transactions: Seq[Transaction]): IO[Unit] =
    generateBlock(transactions).flatMap(blockGenerated)

  def isClientAwaitingReply: IO[Boolean] = clientIsAwaitingReply.get

  private def generateBlock(transactions: Seq[Transaction]): IO[Block] = {
    (currentHeight.getAndUpdate(_ + 1), calculateHash).mapN { case (newHeight, hash) =>
      Block(newHeight, hash, transactions)
    }
  }

  private def calculateHash: IO[Hash] =
    Random[IO]
      .nextBytes(32)
      .map(new java.math.BigInteger(_))
      .map(_.abs())
      .map(String.format("%064x", _))
      .map(Hash(_))

  private def blockGenerated(block: Block): IO[Unit] =
    clientIsAwaitingReply.getAndSet(false).flatMap {
      case true  => responses.offer(RollForward(block))
      case false => blocks.offer(block)
    }
}

object JsonWebSocketClientSyncStub {
  def apply(
      currentHeight: Int = 0,
      initialBlocks: Seq[Block] = Seq.empty,
      initialResponses: Seq[Receive[Block]] = Seq.empty,
  )(implicit R: Random[IO]): IO[JsonWebSocketClientSyncStub] =
    (
      Ref[IO].of(currentHeight),
      Queue.unbounded[IO, Block].flatTap(q => initialBlocks.traverse(q.offer)),
      Queue.unbounded[IO, Receive[Block]].flatTap(q => initialResponses.traverse(q.offer)),
      Ref[IO].of(false),
    ).mapN(new JsonWebSocketClientSyncStub(_, _, _, _))
}
