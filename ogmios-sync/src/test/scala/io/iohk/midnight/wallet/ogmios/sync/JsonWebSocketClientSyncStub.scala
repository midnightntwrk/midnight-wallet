package io.iohk.midnight.wallet.ogmios.sync

import cats.Show
import cats.effect.std.{Queue, Random}
import cats.effect.{Clock, IO, Ref}
import cats.syntax.all.*
import io.circe.{Decoder, Encoder}
import io.iohk.midnight.wallet.blockchain.data
import io.iohk.midnight.wallet.blockchain.data.{Block, Hash, Transaction, TransactionResult}
import io.iohk.midnight.wallet.ogmios.sync.protocol.LocalBlockSync.Receive.RollForward
import io.iohk.midnight.wallet.ogmios.sync.protocol.LocalBlockSync.{Receive, Send}
import io.iohk.midnight.wallet.ogmios.network.JsonWebSocketClient

import java.time.Instant

/** A dummy implementation of a websocket client for syncing. It holds a queue of blocks, simulating
  * the blocks that are in the blockchain but not synced yet. Allows for simulating new blocks
  * generated by the blockchain through an `emitBlock` method.
  */
class JsonWebSocketClientSyncStub(
    currentHeight: Ref[IO, Block.Height],
    blocks: Queue[IO, Block],
    responses: Queue[IO, Receive],
    clientIsAwaitingReply: Ref[IO, Boolean],
)(implicit R: Random[IO])
    extends JsonWebSocketClient[IO] {
  override def send[T: Encoder](message: T): IO[Unit] =
    message match {
      case Send.RequestNext =>
        blocks.tryTake
          .flatMap[Receive] {
            case Some(block) => Receive.RollForward(block).pure[IO].widen
            case None        => clientIsAwaitingReply.set(true).as(Receive.AwaitReply)
          }
          .flatMap(responses.offer)

      case msg =>
        implicit val show: Show[T] = Show.fromToString
        new Exception(s"Unexpected message ${msg.show}").raiseError[IO, Unit]
    }

  override def receive[T: Decoder](): IO[T] =
    responses.take.map(_.asInstanceOf[T])

  def emitBlock(transactions: Seq[Transaction]): IO[Unit] =
    generateBlock(transactions).flatMap(blockGenerated)

  def isClientAwaitingReply: IO[Boolean] = clientIsAwaitingReply.get

  private def generateBlock(transactions: Seq[Transaction]): IO[Block] =
    for {
      blockHeader <- generateBlockHeader
      block = data.Block(
        blockHeader,
        Block.Body(transactions.map(TransactionResult(_, "Successful"))),
      )
    } yield block

  private def generateBlockHeader: IO[Block.Header] =
    (
      calculateHash(),
      currentHeight.getAndUpdate(_.increment),
      Clock[IO].realTime.map(_.toMillis).map(Instant.ofEpochMilli),
    )
      .mapN(Block.Header(_, Hash(""), _, _))

  private def calculateHash(): IO[Hash[Block]] =
    Random[IO]
      .nextBytes(32)
      .map(new java.math.BigInteger(_))
      .map(_.abs())
      .map(String.format("%064x", _))
      .map(Hash[Block])

  private def blockGenerated(block: Block): IO[Unit] =
    clientIsAwaitingReply.getAndSet(false).flatMap {
      case true  => responses.offer(RollForward(block))
      case false => blocks.offer(block)
    }
}

object JsonWebSocketClientSyncStub {
  def apply(
      currentHeight: Block.Height = Block.Height.Genesis,
      initialBlocks: Seq[Block] = Seq.empty,
      initialResponses: Seq[Receive] = Seq.empty,
  )(implicit R: Random[IO]): IO[JsonWebSocketClientSyncStub] =
    (
      Ref[IO].of(currentHeight),
      Queue.unbounded[IO, Block].flatTap(q => initialBlocks.traverse(q.offer)),
      Queue.unbounded[IO, Receive].flatTap(q => initialResponses.traverse(q.offer)),
      Ref[IO].of(false),
    ).mapN(new JsonWebSocketClientSyncStub(_, _, _, _))
}
