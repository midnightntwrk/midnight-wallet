package io.iohk.midnight.wallet.clients.platform

import cats.effect.std.Queue
import cats.effect.{Clock, IO, Ref}
import cats.implicits.toShow
import cats.syntax.applicative.*
import cats.syntax.applicativeError.*
import cats.syntax.apply.*
import cats.syntax.eq.*
import cats.syntax.functor.*
import cats.syntax.traverse.*
import io.iohk.midnight.wallet.clients.platform.PlatformClientStub.rejectDetails
import io.iohk.midnight.wallet.clients.platform.protocol.ReceiveMessage.LocalBlockSync.{
  AwaitReply,
  RollForward,
}
import io.iohk.midnight.wallet.clients.platform.protocol.ReceiveMessage.LocalTxSubmission.{
  AcceptTx,
  RejectTx,
  RejectTxDetails,
}
import io.iohk.midnight.wallet.clients.platform.protocol.SendMessage.LocalBlockSync.RequestNext
import io.iohk.midnight.wallet.clients.platform.protocol.SendMessage.LocalTxSubmission.SubmitTx
import io.iohk.midnight.wallet.clients.platform.protocol.{ReceiveMessage, SendMessage}
import io.iohk.midnight.wallet.domain.*
import io.iohk.midnight.wallet.domain.Hashing.*
import io.iohk.midnight.wallet.util.ClockOps.*
import io.iohk.midnight.wallet.util.implicits.Equality.*

/** A dummy implementation of the platform client. It holds a queue of blocks, simulating the blocks
  * that are in the blockchain but not synced yet. Allows for simulating new blocks generated by the
  * blockchain through an `emitBlock` method. For simplicity, submitted txs to this client won't
  * generate new blocks in the simulated blockchain.
  * @param currentHeight
  * @param blocks
  * @param responses
  * @param clientIsAwaitingReply
  * @param H
  */
class PlatformClientStub(
    currentHeight: Ref[IO, Block.Height],
    blocks: Queue[IO, Block],
    responses: Queue[IO, ReceiveMessage],
    clientIsAwaitingReply: Ref[IO, Boolean],
)(implicit H: Hashing[IO])
    extends PlatformClient[IO] {
  override def send(message: SendMessage): IO[Unit] =
    message match {
      case RequestNext =>
        blocks.tryTake
          .flatMap[ReceiveMessage] {
            case Some(block) => RollForward(block).pure[IO].widen
            case None        => clientIsAwaitingReply.set(true).as(AwaitReply)
          }
          .flatMap(responses.offer)

      case SubmitTx(transaction) =>
        if (isValid(transaction)) responses.offer(AcceptTx)
        else responses.offer(RejectTx(rejectDetails))

      case msg =>
        new Exception(s"Unexpected message ${msg.show}").raiseError[IO, Unit]
    }

  // We don't have a real validation logic, currently all transactions
  // are valid. So let's pretend that only the example call tx is invalid
  // for the sake of testing
  private def isValid(transaction: Transaction): Boolean =
    transaction === examples.SubmitTx.validCallTx

  override def receive(): IO[ReceiveMessage] =
    responses.take

  def emitBlock(transactions: Seq[Transaction]): IO[Unit] =
    generateBlock(transactions).flatMap(blockGenerated)

  private def generateBlock(transactions: Seq[Transaction]): IO[Block] =
    for {
      blockHeader <- generateBlockHeader
      block = Block(blockHeader, transactions.map(TransactionWithReceipt(_, Receipt.Success)))
      hash <- block.calculateHash
    } yield block.copy(header = blockHeader.copy(hash = Some(hash)))

  private def generateBlockHeader: IO[Block.Header] =
    (currentHeight.getAndUpdate(_.increment), Clock[IO].realTimeInstant)
      .mapN(Block.Header(None, Hash(""), _, _))

  private def blockGenerated(block: Block): IO[Unit] =
    clientIsAwaitingReply.getAndSet(false).flatMap {
      case true  => responses.offer(RollForward(block))
      case false => blocks.offer(block)
    }
}

object PlatformClientStub {
  def apply(
      currentHeight: Block.Height = Block.Height.Genesis,
      initialBlocks: Seq[Block] = Seq.empty,
  )(implicit H: Hashing[IO]): IO[PlatformClientStub] =
    (
      Ref[IO].of(currentHeight),
      Queue.unbounded[IO, Block].flatTap(q => initialBlocks.traverse(q.offer)),
      Queue.unbounded[IO, ReceiveMessage],
      Ref[IO].of(false),
    ).mapN(new PlatformClientStub(_, _, _, _))

  val rejectDetails: RejectTxDetails.Other = RejectTxDetails.Other("Invalid")
}
